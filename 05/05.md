# 第5回初心者分科会

## 今日の内容
+ Scopeの話
+ Moduleについて
+ オブジェクト指向とは？
+ Classについて


## 復習

### 名前，オブジェクト，参照について

+ 名前とは，オブジェクトの参照が格納されているもの
+ 例えば，`a="Hello"`と実行すると，str型の"Hello"というデータを持つオブジェクトの参照が，名前aに格納される
![05_01](./img/05_01.png)
+ `a="Python"`のようにaに新しい文字列を代入すると，新しいオブジェクトが作られ，その参照がaに格納される
![05_02](./img/05_02.png)

## Scopeの話

### 名前空間とは？

+ 名前空間とは，名前と参照の対応(keyが名前でvalueが参照であるディクショナリ)を保持している領域のこと
+ ディクショナリのkeyはdir()で確認することができる
+ 普通は，関数によって区切られる，各階層がこの領域にあたる
+ その他にも，オブジェクトのアトリビュートなどがある

例えば，
```python3
def a():
	# 関数a内部の名前空間
	l = 0
	s = 'apple'

	def b():
		# 関数a内部の名前空間
		m = 1
		t = 'banana'
		print('in function b:',dir())

	print('in function a:',dir())
	b()

# globalの名前空間
n = 2
u = 'cake'
a()
print('in global:',dir())

#=>in function a: ['b', 'l', 's']
#=>in function b: ['m', 't']
#=>in global: ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'n', 'u']
```
とすると，関数aの内部と，globalに2つの名前空間ができ，

+ 関数a内部では `{l: 0の参照, s: 'apple'の参照, b: 関数bの参照}`
+ 関数b内部では `{m: 1の参照, t: 'banana'の参照}`
+ globalには `{a: 関数aの参照, n: 2の参照, u: 'banana'の参照, など}`

というデータを含む

### Scopeとは？

+ Scopeとは，ある名前空間(階層)から(直接)アクセスすることができる範囲のこと
+ 直接アクセスするとは`a.b`のように`.`を使って対象を指定せず，`b`のようにアクセスする方法のこと
+ Scopeは視野と言うような意味であり，ある場所に立ったとき，そこから見える変数はどの領域かということである
+ 基本的に，自分より外側の名前が，スコープに含まれる
+ スコープにはいくつかの種類がある

### 名前を検索するときの，名前空間の優先順位

+ 名前を使うと，それに対応する参照を探すために，その名前を持つ名前空間の検索が始まる
+ 何も指定していなければ以下の順に名前が検索される
	+ local(自分の関数内)
	+ nonlocal(localでもglobalでもない中間領域)のうち，よりlocalに近い内側のものから先に検索される
	+ global(自分のModule)
	+ builtins(len(), print(), str()などが入っている)

`print(spam)`がある名前空間から見た，Scope

![05_03](./img/05_03.png)

+ `builtins` は `import builtins`を行うことで操作することができる
+ builtinsがglobalより後に検索されていることがわかる
```python3
import builtins
builtins.spam = "hello"

print(spam)
#=>hello

spam = "python"
print(spam)
#=>python
```

### Scopeの指定
+ 指定できるScopeの種類は3種類あり，それぞれが上で述べた階層に対応する
	+ local
	+ nonlocal
	+ global
+ Scopeを指定することで，そのScope内から名前を探すことができる

```python3
def scope_test():
    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)

#=>After local assignment: test spam
#=>After nonlocal assignment: nonlocal spam
#=>After global assignment: nonlocal spam
#=>In global scope: global spam
```

### クロージャ

+ 関数は，定義されたときの周りの環境を保持している
+ よって，呼び出し時の環境に同じ変数があっても影響を受けない
```python3
def counter():
	def a():
		nonlocal i　# 書き換える必要があるため，nonlocalを宣言した．読み取るだけならいらない．
		i+=1
		return i
	i=0
	return a

cnt1 = counter()
cnt2 = counter()

i=10

print(cnt1())
#=>1
print(cnt1())
#=>2
print(cnt1())
#=>3

print(cnt2())
#=>1
print(cnt2())
#=>2
print(cnt2())
#=>3
```




## Moduleについて



## オブジェクト指向とは？

### オブジェクト指向の目的

+ 再利用性

他の工業の分野では，再利用が盛んに行われている．例えば，回路のICや，車のパーツ(エンジン，タイヤなど)，PCのパーツ(メモリ，HDD，CPUなど)．しかし，プログラミングの分野では行われてこなかった．クラスを，再利用の単位(=部品，パーツ)にすることによって，再利用しやすくする．

再利用性を高めることにより，同じものを何度も使わなくていいため(車輪の再発明を防ぐ)，開発のスピードを高めることができる．また，しっかり整備されたものを使うことによって，バグや脆弱性を防ぐことができる．


+ 拡張性




+ 保守性


### クラスの定義

```python3


```